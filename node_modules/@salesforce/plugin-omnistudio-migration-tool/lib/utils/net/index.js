"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestMethod = exports.NetUtils = void 0;
const lodash_chunk_1 = __importDefault(require("lodash.chunk"));
class NetUtils {
    static async create(connection, objectName, data) {
        // Metadata API only accepts 200 records per request
        const chunks = (0, lodash_chunk_1.default)(data, NetUtils.CHUNK_SIZE), results = new Map();
        for (let curr of chunks) {
            const response = await this.request(connection, `composite/tree/${objectName}`, { records: curr }, RequestMethod.POST);
            response.results.forEach(result => {
                results.set(result.referenceId, {
                    ...result,
                    hasErrors: Array.isArray(result.errors) && result.errors.length > 0
                });
            });
        }
        return results;
    }
    static async createOne(connection, objectName, referenceId, data) {
        try {
            const url = 'sobjects/' + objectName;
            const response = await this.request(connection, url, data, RequestMethod.POST);
            return { ...response, referenceId, hasErrors: response.errors.length > 0 };
        }
        catch (err) {
            return {
                referenceId,
                hasErrors: true,
                success: false,
                errors: err,
                warnings: []
            };
        }
    }
    static async updateOne(connection, objectName, referenceId, recordId, data) {
        try {
            const url = 'sobjects/' + objectName + '/' + recordId;
            await this.request(connection, url, data, RequestMethod.PATCH);
            return {
                referenceId,
                hasErrors: false,
                success: true,
                errors: [],
                warnings: []
            };
        }
        catch (err) {
            return {
                referenceId,
                hasErrors: true,
                success: false,
                errors: err,
                warnings: []
            };
        }
    }
    static async update(connection, data) {
        // Metadata API only accepts 200 records per request
        const chunks = (0, lodash_chunk_1.default)(data, NetUtils.CHUNK_SIZE), results = new Map();
        for (let curr of chunks) {
            const response = await this.request(connection, 'composite/sobjects', { records: curr }, RequestMethod.PATCH);
            response.forEach(result => {
                results.set(result.referenceId || result.id, {
                    ...result,
                    hasErrors: Array.isArray(result.errors) && result.errors.length > 0
                });
            });
        }
        return results;
    }
    static async delete(connection, data) {
        // Metadata API only accepts 200 records per request
        const chunks = (0, lodash_chunk_1.default)(data, NetUtils.CHUNK_SIZE);
        for (let curr of chunks) {
            const deleteUrl = 'composite/sobjects?allOrNone=true&ids=' + curr.join(',');
            const response = await this.request(connection, deleteUrl, [], RequestMethod.DELETE);
            if (!response.every(r => r.success))
                return false;
        }
        return true;
    }
    static async request(connection, url, data, method) {
        const apiVersion = connection.getApiVersion();
        const metadataApiUrl = `/services/data/v${apiVersion}/${url}`;
        const request = {
            method: method,
            url: metadataApiUrl,
            body: JSON.stringify(data)
        };
        const response = await connection.request(request);
        return response;
    }
}
exports.NetUtils = NetUtils;
NetUtils.CHUNK_SIZE = 200;
var RequestMethod;
(function (RequestMethod) {
    RequestMethod["POST"] = "post";
    RequestMethod["GET"] = "get";
    RequestMethod["PATCH"] = "patch";
    RequestMethod["DELETE"] = "delete";
})(RequestMethod || (RequestMethod = {}));
exports.RequestMethod = RequestMethod;
//# sourceMappingURL=index.js.map