"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/explicit-member-accessibility */
// import * as fs from 'fs';
// import { parse, type ParseResult } from '@babel/parser'; // Import all types from @babel/types
Object.defineProperty(exports, "__esModule", { value: true });
class JavaScriptParser {
    constructor(filePath) {
        // private fileContent: string;
        this.ast = null; // Specify the generic type argument
        // this.fileContent = fs.readFileSync(filePath, 'utf-8');
        this.ast = null;
    }
    // public parseCode(): void {
    //   const parseResult: File = parse(this.fileContent, {
    //     sourceType: 'module', // Use 'script' if you're parsing non-module code
    //     plugins: ['jsx', 'typescript'], // Add plugins as needed
    //   });
    //   if (parseResult.type === 'File') {
    //     this.ast = parseResult;
    //   } else {
    //     throw new Error("Parsing did not return a 'File' node as expected.");
    //   }
    // }
    // Method to get the AST as a string
    getAST() {
        if (!this.ast) {
            console.error('AST is not available. Please parse the code first.');
            return null;
        }
        return JSON.stringify(this.ast, null, 2);
    }
    // Main method to process the file
    processFile() {
        // this.parseCode(); // Parse the JavaScript code
        const astString = this.getAST(); // Get the AST as a string
        if (astString) {
            console.log(astString); // Output the AST
        }
    }
}
exports.default = JavaScriptParser;
//# sourceMappingURL=JavaScriptParser.js.map