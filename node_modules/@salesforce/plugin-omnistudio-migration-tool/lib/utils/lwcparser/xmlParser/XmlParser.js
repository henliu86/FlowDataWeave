"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlParser = void 0;
/* eslint-disable @typescript-eslint/no-inferrable-types */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/member-ordering */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/explicit-member-accessibility */
const xmldom_1 = require("xmldom");
class XmlParser {
    constructor(xmlString) {
        this.xmlString = xmlString;
        this.xmlDoc = null;
        this.parseXml();
    }
    parseXml() {
        const parser = new xmldom_1.DOMParser();
        this.xmlDoc = parser.parseFromString(this.xmlString, 'text/xml');
    }
    removeNode(tagName, index = 0) {
        var _a;
        if (!this.xmlDoc) {
            throw new Error('XML document has not been parsed.');
        }
        const nodes = this.xmlDoc.getElementsByTagName(tagName);
        if (nodes.length > index) {
            const nodeToRemove = nodes[index];
            (_a = nodeToRemove.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(nodeToRemove);
        }
        else {
            throw new Error(`No node found with tag name "${tagName}" at index ${index}.`);
        }
    }
    getXmlString() {
        if (!this.xmlDoc) {
            throw new Error('XML document has not been parsed.');
        }
        const serializer = new xmldom_1.XMLSerializer();
        return serializer.serializeToString(this.xmlDoc);
    }
}
exports.XmlParser = XmlParser;
//# sourceMappingURL=XmlParser.js.map