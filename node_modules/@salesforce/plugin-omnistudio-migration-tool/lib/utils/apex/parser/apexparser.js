"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApexASTParser = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
const apex_parser_1 = require("@apexdevtools/apex-parser");
const antlr4ts_1 = require("antlr4ts");
const ParseTreeWalker_1 = require("antlr4ts/tree/ParseTreeWalker");
class ApexASTParser {
    get implemementsInterface() {
        return this.implementsInterface;
    }
    constructor(apexFileContent, interfaceName, methodName) {
        this.implementsInterface = new Map();
        this.apexFileContent = apexFileContent;
        this.interfaceName = interfaceName;
        this.methodName = methodName;
        this.astListener = this.createASTListener();
    }
    parse() {
        const lexer = new apex_parser_1.ApexLexer(new apex_parser_1.CaseInsensitiveInputStream(antlr4ts_1.CharStreams.fromString(this.apexFileContent)));
        const tokens = new apex_parser_1.CommonTokenStream(lexer);
        const parser = new apex_parser_1.ApexParser(tokens);
        const context = parser.compilationUnit();
        //  parser.addParseListener(new interfaceVisitor() as ApexParserListener);
        ParseTreeWalker_1.ParseTreeWalker.DEFAULT.walk(this.astListener, context);
        return context;
    }
    createASTListener() {
        class ApexMigrationListener {
            constructor(parser) {
                this.parser = parser;
            }
            enterClassDeclaration(ctx) {
                const interfaceToBeSearched = this.parser.interfaceName;
                if (!interfaceToBeSearched)
                    return;
                if (!ctx.typeList() || !ctx.typeList().typeRef())
                    return;
                for (const typeRefContext of ctx.typeList().typeRef())
                    for (const typeNameContext of typeRefContext.typeName()) {
                        if (!typeNameContext.id() || !typeNameContext.id().Identifier())
                            continue;
                        if (typeNameContext.id().Identifier().symbol.text === interfaceToBeSearched) {
                            this.parser.implementsInterface.set(interfaceToBeSearched, typeNameContext.id().Identifier().symbol);
                        }
                    }
            }
            enterDotExpression(ctx) {
                // console.log('*********');
                // console.log(ctx.expression().start.text);
                if (ctx.dotMethodCall() && this.parser.methodName) {
                    // console.log(ctx.dotMethodCall().anyId().Identifier().symbol.text);
                    // ctx.dotMethodCall().expressionList().expression(1).children[0].children[0].children[0];
                    // console.log(ctx.dotMethodCall().expressionList().expression(1).children[0]);
                }
                // console.log('*********');
            }
            enterVariableDeclarator(ctx) {
                if (ctx.id().Identifier().symbol.text === 'DRName') {
                    // console.log(ctx.expression());
                }
            }
        }
        return new ApexMigrationListener(this);
    }
}
exports.ApexASTParser = ApexASTParser;
// const filePath = '/Users/abhinavkumar2/company/plugin-omnistudio-migration-tool/test/FormulaParserService.cls';
// new ApexASTParser(filePath, 'callable', '').parse(filePath);
// console.log(ast);
//# sourceMappingURL=apexparser.js.map