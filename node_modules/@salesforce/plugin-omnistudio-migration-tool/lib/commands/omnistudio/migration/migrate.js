"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = __importStar(require("os"));
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
require("../../../utils/prototypes");
const basecommand_1 = __importDefault(require("../../basecommand"));
const dataraptor_1 = require("../../../migration/dataraptor");
const utils_1 = require("../../../utils");
const resultsbuilder_1 = require("../../../utils/resultsbuilder");
const flexcard_1 = require("../../../migration/flexcard");
const omniscript_1 = require("../../../migration/omniscript");
const logger_1 = require("../../../utils/logger");
// Initialize Messages with the current plugin directory
core_1.Messages.importMessagesDirectory(__dirname);
// Load the specific messages for this file. Messages from @salesforce/command, @salesforce/core,
// or any library that is using the messages framework can also be loaded this way.
const messages = core_1.Messages.loadMessages('@salesforce/plugin-omnistudio-migration-tool', 'migrate');
class Migrate extends basecommand_1.default {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async run() {
        const namespace = (this.flags.namespace || 'vlocity_ins');
        const apiVersion = (this.flags.apiversion || '55.0');
        const migrateOnly = (this.flags.only || '');
        const allVersions = this.flags.allversions || false;
        logger_1.Logger.initialiseLogger(this.ux, this.logger);
        this.logger = logger_1.Logger.logger;
        // this.org is guaranteed because requiresUsername=true, as opposed to supportsUsername
        const conn = this.org.getConnection();
        conn.setApiVersion(apiVersion);
        // Let's time every step
        utils_1.DebugTimer.getInstance().start();
        // Register the migration objects
        let migrationObjects = [];
        if (!migrateOnly) {
            migrationObjects = [
                new dataraptor_1.DataRaptorMigrationTool(namespace, conn, this.logger, messages, this.ux),
                new omniscript_1.OmniScriptMigrationTool(omniscript_1.OmniScriptExportType.All, namespace, conn, this.logger, messages, this.ux, allVersions),
                new flexcard_1.CardMigrationTool(namespace, conn, this.logger, messages, this.ux, allVersions),
            ];
        }
        else {
            switch (migrateOnly) {
                case 'os':
                    migrationObjects.push(new omniscript_1.OmniScriptMigrationTool(omniscript_1.OmniScriptExportType.OS, namespace, conn, this.logger, messages, this.ux, allVersions));
                    break;
                case 'ip':
                    migrationObjects.push(new omniscript_1.OmniScriptMigrationTool(omniscript_1.OmniScriptExportType.IP, namespace, conn, this.logger, messages, this.ux, allVersions));
                    break;
                case 'fc':
                    migrationObjects.push(new flexcard_1.CardMigrationTool(namespace, conn, this.logger, messages, this.ux, allVersions));
                    break;
                case 'dr':
                    migrationObjects.push(new dataraptor_1.DataRaptorMigrationTool(namespace, conn, this.logger, messages, this.ux));
                    break;
                default:
                    throw new Error(messages.getMessage('invalidOnlyFlag'));
            }
        }
        // Migrate individual objects
        const debugTimer = utils_1.DebugTimer.getInstance();
        let objectMigrationResults = [];
        // We need to truncate the standard objects first
        let allTruncateComplete = true;
        for (const cls of migrationObjects.reverse()) {
            try {
                logger_1.Logger.ux.log('Cleaning: ' + cls.getName());
                debugTimer.lap('Cleaning: ' + cls.getName());
                await cls.truncate();
            }
            catch (ex) {
                allTruncateComplete = false;
                objectMigrationResults.push({
                    name: cls.getName(),
                    errors: [ex.message],
                });
            }
        }
        if (allTruncateComplete) {
            for (const cls of migrationObjects.reverse()) {
                try {
                    this.ux.log('Migrating: ' + cls.getName());
                    debugTimer.lap('Migrating: ' + cls.getName());
                    const results = await cls.migrate();
                    objectMigrationResults = objectMigrationResults.concat(results.map((r) => {
                        return {
                            name: r.name,
                            data: this.mergeRecordAndUploadResults(r, cls),
                        };
                    }));
                }
                catch (ex) {
                    this.logger.error(JSON.stringify(ex));
                    objectMigrationResults.push({
                        name: cls.getName(),
                        errors: [ex.message],
                    });
                }
            }
        }
        // Stop the debug timer
        const timer = utils_1.DebugTimer.getInstance().stop();
        await resultsbuilder_1.ResultsBuilder.generate(objectMigrationResults, conn.instanceUrl);
        // save timer to debug logger
        this.logger.debug(timer);
        // Return results needed for --json flag
        return { objectMigrationResults };
    }
    mergeRecordAndUploadResults(migrationResults, migrationTool) {
        const mergedResults = [];
        for (const record of Array.from(migrationResults.records.values())) {
            const obj = {
                id: record['Id'],
                name: migrationTool.getRecordName(record),
                status: 'Skipped',
                errors: record['errors'],
                migratedId: undefined,
                warnings: [],
                migratedName: '',
            };
            if (migrationResults.results.has(record['Id'])) {
                const recordResults = migrationResults.results.get(record['Id']);
                let errors = obj.errors || [];
                errors = errors.concat(recordResults.errors || []);
                obj.status = !recordResults || recordResults.hasErrors ? 'Error' : 'Complete';
                obj.errors = errors;
                obj.migratedId = recordResults.id;
                obj.warnings = recordResults.warnings;
                obj.migratedName = recordResults.newName;
            }
            mergedResults.push(obj);
        }
        return mergedResults;
    }
}
exports.default = Migrate;
Migrate.description = messages.getMessage('commandDescription');
Migrate.examples = messages.getMessage('examples').split(os.EOL);
Migrate.args = [{ name: 'file' }];
Migrate.flagsConfig = {
    namespace: command_1.flags.string({
        char: 'n',
        description: messages.getMessage('namespaceFlagDescription'),
    }),
    only: command_1.flags.string({
        char: 'o',
        description: messages.getMessage('onlyFlagDescription'),
    }),
    allversions: command_1.flags.boolean({
        char: 'a',
        description: messages.getMessage('allVersionsDescription'),
        required: false,
    }),
};
//# sourceMappingURL=migrate.js.map