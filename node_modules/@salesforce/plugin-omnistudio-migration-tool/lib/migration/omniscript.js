"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OmniScriptExportType = exports.OmniScriptMigrationTool = void 0;
const OmniScript_1 = __importDefault(require("../mappings/OmniScript"));
const Element_1 = __importDefault(require("../mappings/Element"));
const OmniScriptDefinition_1 = __importDefault(require("../mappings/OmniScriptDefinition"));
const utils_1 = require("../utils");
const base_1 = require("./base");
const net_1 = require("../utils/net");
class OmniScriptMigrationTool extends base_1.BaseMigrationTool {
    constructor(exportType, namespace, connection, logger, messages, ux, allVersions) {
        super(namespace, connection, logger, messages, ux);
        this.exportType = exportType;
        this.allVersions = allVersions;
    }
    getName() {
        return 'OmniScript / Integration Procedures';
    }
    getRecordName(record) {
        return (record[this.namespacePrefix + 'Type__c'] +
            '_' +
            record[this.namespacePrefix + 'SubType__c'] +
            (record[this.namespacePrefix + 'Language__c'] ? '_' + record[this.namespacePrefix + 'Language__c'] : '') +
            '_' +
            record[this.namespacePrefix + 'Version__c']);
    }
    getMappings() {
        return [
            {
                source: OmniScriptMigrationTool.OMNISCRIPT_NAME,
                target: OmniScriptMigrationTool.OMNIPROCESS_NAME,
            },
            {
                source: OmniScriptMigrationTool.ELEMENT_NAME,
                target: OmniScriptMigrationTool.OMNIPROCESSELEMENT_NAME,
            },
            {
                source: OmniScriptMigrationTool.OMNISCRIPTDEFINITION_NAME,
                target: OmniScriptMigrationTool.OMNIPROCESSCOMPILATION_NAME,
            },
        ];
    }
    async truncate() {
        const objectName = OmniScriptMigrationTool.OMNIPROCESS_NAME;
        const allIds = await this.deactivateRecord(objectName);
        await this.truncateElements(objectName, allIds.os.parents);
        await this.truncateElements(objectName, allIds.os.childs);
        await this.truncateElements(objectName, allIds.ip.parents);
        await this.truncateElements(objectName, allIds.ip.childs);
    }
    async truncateElements(objectName, ids) {
        if (!ids || ids.length === 0) {
            return;
        }
        let success = await net_1.NetUtils.delete(this.connection, ids);
        if (!success) {
            throw new Error(this.messages.getMessage('couldNotTruncateOmnniProcess').formatUnicorn(objectName));
        }
    }
    async deactivateRecord(objectName) {
        utils_1.DebugTimer.getInstance().lap('Truncating ' + objectName + ' (' + this.exportType + ')');
        const filters = new Map();
        const sorting = [
            { field: 'IsIntegrationProcedure', direction: utils_1.SortDirection.ASC },
            { field: 'IsOmniScriptEmbeddable', direction: utils_1.SortDirection.ASC },
        ];
        // Filter if only IP / OS
        if (this.exportType === OmniScriptExportType.IP) {
            filters.set('IsIntegrationProcedure', true);
        }
        else if (this.exportType === OmniScriptExportType.OS) {
            filters.set('IsIntegrationProcedure', false);
        }
        // const ids: string[] = await QueryTools.queryIds(this.connection, objectName, filters);
        const rows = await utils_1.QueryTools.query(this.connection, objectName, ['Id', 'IsIntegrationProcedure', 'IsOmniScriptEmbeddable'], filters, sorting);
        if (rows.length === 0) {
            return { os: { parents: [], childs: [] }, ip: { parents: [], childs: [] } };
        }
        // We need to update one item at time. Otherwise, we'll have an UNKNOWN_ERROR
        for (let row of rows) {
            const id = row['Id'];
            await net_1.NetUtils.request(this.connection, `sobjects/${OmniScriptMigrationTool.OMNIPROCESS_NAME}/${id}`, {
                IsActive: false,
            }, net_1.RequestMethod.PATCH);
        }
        // Sleep 5 seconds, let's wait for all row locks to be released. While this takes less than a second, there has been
        // times where it take a bit more.
        await this.sleep();
        return {
            os: {
                parents: rows
                    .filter((row) => row.IsIntegrationProcedure === false && row.IsOmniScriptEmbeddable === false)
                    .map((row) => row.Id),
                childs: rows
                    .filter((row) => row.IsIntegrationProcedure === false && row.IsOmniScriptEmbeddable === true)
                    .map((row) => row.Id),
            },
            ip: {
                parents: rows
                    .filter((row) => row.IsIntegrationProcedure === true && row.IsOmniScriptEmbeddable === false)
                    .map((row) => row.Id),
                childs: rows
                    .filter((row) => row.IsIntegrationProcedure === true && row.IsOmniScriptEmbeddable === true)
                    .map((row) => row.Id),
            },
        };
    }
    async migrate() {
        // Get All Records from OmniScript__c (IP & OS Parent Records)
        const omniscripts = await this.getAllOmniScripts();
        const duplicatedNames = new Set();
        // Variables to be returned After Migration
        let done = 0;
        let originalOsRecords = new Map();
        let osUploadInfo = new Map();
        const total = omniscripts.length;
        for (let omniscript of omniscripts) {
            const mappedRecords = [];
            // const originalRecords = new Map<string, AnyJson>();
            const recordId = omniscript['Id'];
            const isOsActive = omniscript[`${this.namespacePrefix}IsActive__c`];
            this.reportProgress(total, done);
            // Create a map of the original OmniScript__c records
            originalOsRecords.set(recordId, omniscript);
            // Record is Active, Elements can't be Added, Modified or Deleted for that OS/IP
            omniscript[`${this.namespacePrefix}IsActive__c`] = false;
            // Get All elements for each OmniScript__c record(i.e IP/OS)
            const elements = await this.getAllElementsForOmniScript(recordId);
            // Perform the transformation for OS/IP Parent Record from OmniScript__c
            const mappedOmniScript = this.mapOmniScriptRecord(omniscript);
            // Clean type, subtype
            mappedOmniScript[OmniScript_1.default.Type__c] = this.cleanName(mappedOmniScript[OmniScript_1.default.Type__c]);
            mappedOmniScript[OmniScript_1.default.SubType__c] = this.cleanName(mappedOmniScript[OmniScript_1.default.SubType__c]);
            // Check duplicated name
            let mappedOsName;
            if (this.allVersions) {
                mappedOmniScript[OmniScript_1.default.Version__c] = omniscript[`${this.namespacePrefix}Version__c`];
                mappedOsName =
                    mappedOmniScript[OmniScript_1.default.Type__c] +
                        '_' +
                        mappedOmniScript[OmniScript_1.default.SubType__c] +
                        (mappedOmniScript[OmniScript_1.default.Language__c]
                            ? '_' + mappedOmniScript[OmniScript_1.default.Language__c]
                            : '') +
                        '_' +
                        mappedOmniScript[OmniScript_1.default.Version__c];
            }
            else {
                mappedOsName =
                    mappedOmniScript[OmniScript_1.default.Type__c] +
                        '_' +
                        mappedOmniScript[OmniScript_1.default.SubType__c] +
                        (mappedOmniScript[OmniScript_1.default.Language__c]
                            ? '_' + mappedOmniScript[OmniScript_1.default.Language__c]
                            : '') +
                        '_1';
            }
            if (duplicatedNames.has(mappedOsName)) {
                this.setRecordErrors(omniscript, this.messages.getMessage('duplicatedOSName'));
                originalOsRecords.set(recordId, omniscript);
                continue;
            }
            // Save the mapped record
            duplicatedNames.add(mappedOsName);
            mappedRecords.push(mappedOmniScript);
            // Save the OmniScript__c records to Standard BPO i.e OmniProcess
            const osUploadResponse = await net_1.NetUtils.createOne(this.connection, OmniScriptMigrationTool.OMNIPROCESS_NAME, recordId, mappedOmniScript);
            if (osUploadResponse.success) {
                // Fix errors
                if (!osUploadResponse.success) {
                    osUploadResponse.errors = Array.isArray(osUploadResponse.errors)
                        ? osUploadResponse.errors
                        : [osUploadResponse.errors];
                }
                osUploadResponse.warnings = osUploadResponse.warnings || [];
                const originalOsName = omniscript[this.namespacePrefix + 'Type__c'] +
                    '_' +
                    omniscript[this.namespacePrefix + 'SubType__c'] +
                    '_' +
                    omniscript[this.namespacePrefix + 'Language__c'];
                if (originalOsName !== mappedOsName) {
                    osUploadResponse.newName = mappedOsName;
                    osUploadResponse.warnings.unshift('WARNING: OmniScript name has been modified to fit naming rules: ' + mappedOsName);
                }
                try {
                    // Upload All elements for each OmniScript__c record(i.e IP/OS)
                    await this.uploadAllElements(osUploadResponse, elements);
                    // Get OmniScript Compiled Definitions for OmniScript Record
                    const omniscriptsCompiledDefinitions = await this.getOmniScriptCompiledDefinition(recordId);
                    // Upload OmniScript Compiled Definition to OmniProcessCompilation
                    await this.uploadAllOmniScriptDefinitions(osUploadResponse, omniscriptsCompiledDefinitions);
                    if (isOsActive) {
                        // Update the inserted OS record as it was Active and made InActive to insert.
                        mappedRecords[0].IsActive = true;
                        mappedRecords[0].Id = osUploadResponse.id;
                        if (mappedRecords[0].IsIntegrationProcedure) {
                            mappedRecords[0].Language = 'Procedure';
                        }
                        const updateResult = await net_1.NetUtils.updateOne(this.connection, OmniScriptMigrationTool.OMNIPROCESS_NAME, recordId, osUploadResponse.id, {
                            [OmniScript_1.default.IsActive__c]: true,
                        });
                        if (!updateResult.success) {
                            osUploadResponse.hasErrors = true;
                            osUploadResponse.errors = osUploadResponse.errors || [];
                            osUploadResponse.errors.push(this.messages.getMessage('errorWhileActivatingOs') + updateResult.errors);
                        }
                    }
                }
                catch (e) {
                    osUploadResponse.hasErrors = true;
                    osUploadResponse.errors = osUploadResponse.errors || [];
                    let error = 'UNKNOWN';
                    if (typeof e === 'object') {
                        try {
                            const obj = JSON.parse(e.message || '{}');
                            if (obj.hasErrors && obj.results && Array.isArray(obj.results)) {
                                error = obj.results
                                    .map((r) => {
                                    return Array.isArray(r.errors) ? r.errors.map((e) => e.message).join('. ') : r.errors;
                                })
                                    .join('. ');
                            }
                        }
                        catch {
                            error = e.toString();
                        }
                    }
                    osUploadResponse.errors.push(this.messages.getMessage('errorWhileCreatingElements') + error);
                }
                finally {
                    // Create the return records and response which have been processed
                    osUploadInfo.set(recordId, osUploadResponse);
                }
            }
            originalOsRecords.set(recordId, omniscript);
            done++;
        }
        const objectMigrationResults = [];
        if (this.exportType === OmniScriptExportType.All || this.exportType === OmniScriptExportType.IP) {
            objectMigrationResults.push(this.getMigratedRecordsByType('Integration Procedures', osUploadInfo, originalOsRecords));
        }
        if (this.exportType === OmniScriptExportType.All || this.exportType === OmniScriptExportType.OS) {
            objectMigrationResults.push(this.getMigratedRecordsByType('OmniScripts', osUploadInfo, originalOsRecords));
        }
        return objectMigrationResults;
    }
    // Using this small method, As IP & OS lives in same object -> So returning the IP and OS in the end, after the migration is done
    // and the results are generated. Other way can be creating a separate IP class and migrating IP & OS separately
    // using common functions
    getMigratedRecordsByType(type, results, records) {
        let recordMap = new Map();
        let resultMap = new Map();
        for (let record of Array.from(records.values())) {
            if ((type === 'Integration Procedures' && record[`${this.namespacePrefix}IsProcedure__c`]) ||
                (type === 'OmniScripts' && !record[`${this.namespacePrefix}IsProcedure__c`])) {
                recordMap.set(record['Id'], records.get(record['Id']));
                if (results.get(record['Id'])) {
                    resultMap.set(record['Id'], results.get(record['Id']));
                }
            }
        }
        return {
            name: type,
            records: recordMap,
            results: resultMap,
        };
    }
    // Get All OmniScript__c records i.e All IP & OS
    async getAllOmniScripts() {
        utils_1.DebugTimer.getInstance().lap('Query OmniScripts');
        this.logger.info('allVersions : ' + this.allVersions);
        const filters = new Map();
        if (this.exportType === OmniScriptExportType.IP) {
            filters.set(this.namespacePrefix + 'IsProcedure__c', true);
        }
        else if (this.exportType === OmniScriptExportType.OS) {
            filters.set(this.namespacePrefix + 'IsProcedure__c', false);
        }
        if (this.allVersions) {
            const sortFields = [
                { field: this.namespacePrefix + 'Type__c', direction: utils_1.SortDirection.ASC },
                { field: this.namespacePrefix + 'SubType__c', direction: utils_1.SortDirection.ASC },
                { field: this.namespacePrefix + 'Version__c', direction: utils_1.SortDirection.ASC },
            ];
            return await utils_1.QueryTools.queryWithFilterAndSort(this.connection, this.namespace, OmniScriptMigrationTool.OMNISCRIPT_NAME, this.getOmniScriptFields(), filters, sortFields);
        }
        else {
            filters.set(this.namespacePrefix + 'IsActive__c', true);
            return await utils_1.QueryTools.queryWithFilter(this.connection, this.namespace, OmniScriptMigrationTool.OMNISCRIPT_NAME, this.getOmniScriptFields(), filters);
        }
    }
    // Get All Elements w.r.t OmniScript__c i.e Elements tagged to passed in IP/OS
    async getAllElementsForOmniScript(recordId) {
        // Query all Elements for an OmniScript
        const filters = new Map();
        filters.set(this.namespacePrefix + 'OmniScriptId__c', recordId);
        // const queryFilterStr = ` Where ${this.namespacePrefix}OmniScriptId__c = '${omniScriptData.keys().next().value}'`;
        return await utils_1.QueryTools.queryWithFilter(this.connection, this.namespace, OmniScriptMigrationTool.ELEMENT_NAME, this.getElementFields(), filters);
    }
    // Get All Compiled Definitions w.r.t OmniScript__c i.e Definitions tagged to passed in IP/OS
    async getOmniScriptCompiledDefinition(recordId) {
        // Query all Definitions for an OmniScript
        const filters = new Map();
        filters.set(this.namespacePrefix + 'OmniScriptId__c', recordId);
        // const queryFilterStr = ` Where ${this.namespacePrefix}OmniScriptId__c = '${omniScriptData.keys().next().value}'`;
        return await utils_1.QueryTools.queryWithFilter(this.connection, this.namespace, OmniScriptMigrationTool.OMNISCRIPTDEFINITION_NAME, this.getOmniScriptDefinitionFields(), filters);
    }
    // Upload All the Elements tagged to a OmniScript__c record, after the parent record has been inserted
    async uploadAllElements(omniScriptUploadResults, elements) {
        let levelCount = 0; // To define and insert different levels(Parent-Child relationship) at a time
        let exit = false; // Counter variable to exit after all parent-child elements inserted
        var elementsUploadInfo = new Map(); // Info for Uploaded Elements to be returned
        do {
            let tempElements = []; // Stores Elements at a same level starting with levelCount = 0 level (parent elements)
            for (let element of elements) {
                if (element[`${this.namespacePrefix}Level__c`] === levelCount) {
                    let elementId = element['Id'];
                    let elementParentId = element[`${this.namespacePrefix}ParentElementId__c`];
                    if (!elementsUploadInfo.has(elementId) &&
                        (!elementParentId || (elementParentId && elementsUploadInfo.has(elementParentId)))) {
                        tempElements.push(element);
                    }
                }
            }
            // If no elements exist after a certain level, Then everything is alraedy processed, otherwise upload
            if (tempElements.length === 0) {
                exit = true;
            }
            else {
                // Get Transformed Element__c to OmniProcessElement with updated OmniScriptId & ParentElementId
                let elementsTransformedData = await this.prepareElementsData(omniScriptUploadResults, tempElements, elementsUploadInfo);
                // Upload the transformed Element__c
                let elementsUploadResponse = await this.uploadTransformedData(OmniScriptMigrationTool.OMNIPROCESSELEMENT_NAME, elementsTransformedData);
                // Keep appending upload Info for Elements at each level
                elementsUploadInfo = new Map([
                    ...Array.from(elementsUploadInfo.entries()),
                    ...Array.from(elementsUploadResponse.entries()),
                ]);
            }
            levelCount++;
        } while (exit === false);
        return elementsUploadInfo;
    }
    // Upload All the Definitions tagged to a OmniScript__c record, after the parent record has been inserted
    async uploadAllOmniScriptDefinitions(omniScriptUploadResults, osDefinitions) {
        let osDefinitionsData = await this.prepareOsDefinitionsData(omniScriptUploadResults, osDefinitions);
        return await this.uploadTransformedData(OmniScriptMigrationTool.OMNIPROCESSCOMPILATION_NAME, osDefinitionsData);
    }
    // Prepare Elements Data and Do the neccessary updates, transformation, validations etc.
    async prepareElementsData(osUploadResult, elements, parentElementUploadResponse) {
        const mappedRecords = [], originalRecords = new Map(), invalidIpNames = new Map();
        elements.forEach((element) => {
            // Perform the transformation. We need parent record & must have been migrated before
            if (osUploadResult.id) {
                mappedRecords.push(this.mapElementData(element, osUploadResult.id, parentElementUploadResponse, invalidIpNames));
            }
            // Create a map of the original records
            originalRecords.set(element['Id'], element);
        });
        if (osUploadResult.id && invalidIpNames.size > 0) {
            const val = Array.from(invalidIpNames.entries())
                .map((e) => e[0])
                .join(', ');
            osUploadResult.errors.push('Integration Procedure Actions will need manual updates, please verify: ' + val);
        }
        return { originalRecords, mappedRecords };
    }
    // Prepare OmniScript Definitions to be uploaded
    async prepareOsDefinitionsData(osUploadResult, osDefinitions) {
        const mappedRecords = [], originalRecords = new Map();
        osDefinitions.forEach((osDefinition) => {
            // Perform the transformation. We need parent record & must have been migrated before
            if (osUploadResult.id) {
                mappedRecords.push(this.mapOsDefinitionsData(osDefinition, osUploadResult.id));
            }
            // Create a map of the original records
            originalRecords.set(osDefinition['Id'], osDefinition);
        });
        return { originalRecords, mappedRecords };
    }
    /**
     * Maps an omniscript__c record to OmniProcess Record.
     * @param omniScriptRecord
     * @returns
     */
    mapOmniScriptRecord(omniScriptRecord) {
        // Transformed object
        const mappedObject = {};
        // Get the fields of the record
        const recordFields = Object.keys(omniScriptRecord);
        // Map individual fields
        recordFields.forEach((recordField) => {
            const cleanFieldName = this.getCleanFieldName(recordField);
            if (OmniScript_1.default.hasOwnProperty(cleanFieldName)) {
                mappedObject[OmniScript_1.default[cleanFieldName]] = omniScriptRecord[recordField];
            }
        });
        mappedObject['Name'] = this.cleanName(mappedObject['Name']);
        // BATCH framework requires that each record has an "attributes" property
        mappedObject['attributes'] = {
            type: OmniScriptMigrationTool.OMNIPROCESS_NAME,
            referenceId: omniScriptRecord['Id'],
        };
        return mappedObject;
    }
    // Maps an individual Element into an OmniProcessElement record
    mapElementData(elementRecord, omniProcessId, parentElementUploadResponse, invalidIpReferences) {
        // Transformed object
        const mappedObject = {};
        // Get the fields of the record
        const recordFields = Object.keys(elementRecord);
        // Map individual fields
        recordFields.forEach((recordField) => {
            const cleanFieldName = this.getCleanFieldName(recordField);
            if (Element_1.default.hasOwnProperty(cleanFieldName)) {
                mappedObject[Element_1.default[cleanFieldName]] = elementRecord[recordField];
                if (cleanFieldName === 'ParentElementId__c' &&
                    parentElementUploadResponse.has(elementRecord[`${this.namespacePrefix}ParentElementId__c`])) {
                    mappedObject[Element_1.default[cleanFieldName]] = parentElementUploadResponse.get(elementRecord[`${this.namespacePrefix}ParentElementId__c`]).id;
                }
            }
        });
        // Set the parent/child relationship
        mappedObject['OmniProcessId'] = omniProcessId;
        // We need to fix the child references
        const elementType = mappedObject[Element_1.default.Type__c];
        const propertySet = JSON.parse(mappedObject[Element_1.default.PropertySet__c] || '{}');
        switch (elementType) {
            case 'OmniScript':
                propertySet['Type'] = this.cleanName(propertySet['Type']);
                propertySet['Sub Type'] = this.cleanName(propertySet['Sub Type']);
                break;
            case 'Integration Procedure Action':
                const remoteOptions = propertySet['remoteOptions'] || {};
                remoteOptions['preTransformBundle'] = this.cleanName(remoteOptions['preTransformBundle']);
                remoteOptions['postTransformBundle'] = this.cleanName(remoteOptions['postTransformBundle']);
                propertySet['remoteOptions'] = remoteOptions;
                propertySet['preTransformBundle'] = this.cleanName(propertySet['preTransformBundle']);
                propertySet['postTransformBundle'] = this.cleanName(propertySet['postTransformBundle']);
                // We can't update the IP references, we need to let the user know
                const key = propertySet['integrationProcedureKey'] || '';
                if (key) {
                    const parts = key.split('_');
                    const newKey = parts.map((p) => this.cleanName(p, true)).join('_');
                    if (parts.length > 2) {
                        invalidIpReferences.set(mappedObject[Element_1.default.Name], key);
                    }
                    propertySet['integrationProcedureKey'] = newKey;
                }
                break;
            case 'DataRaptor Turbo Action':
            case 'DataRaptor Transform Action':
            case 'DataRaptor Post Action':
            case 'DataRaptor Extract Action':
                propertySet['bundle'] = this.cleanName(propertySet['bundle']);
                break;
        }
        mappedObject[Element_1.default.PropertySet__c] = JSON.stringify(propertySet);
        // BATCH framework requires that each record has an "attributes" property
        mappedObject['attributes'] = {
            type: OmniScriptMigrationTool.OMNIPROCESSELEMENT_NAME,
            referenceId: elementRecord['Id'],
        };
        return mappedObject;
    }
    // Maps an individual Definition into an OmniProcessCompilation record
    mapOsDefinitionsData(osDefinition, omniProcessId) {
        // Transformed object
        const mappedObject = {};
        // Get the fields of the record
        const recordFields = Object.keys(osDefinition);
        // Map individual fields
        recordFields.forEach((recordField) => {
            const cleanFieldName = this.getCleanFieldName(recordField);
            if (OmniScriptDefinition_1.default.hasOwnProperty(cleanFieldName)) {
                mappedObject[OmniScriptDefinition_1.default[cleanFieldName]] = osDefinition[recordField];
            }
        });
        // Set the parent/child relationship
        mappedObject[OmniScriptDefinition_1.default.Name] = omniProcessId;
        mappedObject[OmniScriptDefinition_1.default.OmniScriptId__c] = omniProcessId;
        let content = mappedObject[OmniScriptDefinition_1.default.Content__c];
        if (content) {
            try {
                content = JSON.parse(content);
                if (content && content['sOmniScriptId']) {
                    content['sOmniScriptId'] = omniProcessId;
                    mappedObject[OmniScriptDefinition_1.default.Content__c] = JSON.stringify(content);
                }
            }
            catch (ex) {
                // Log
            }
        }
        // BATCH framework requires that each record has an "attributes" property
        mappedObject['attributes'] = {
            type: OmniScriptMigrationTool.OMNIPROCESSCOMPILATION_NAME,
            referenceId: osDefinition['Id'],
        };
        return mappedObject;
    }
    getOmniScriptFields() {
        return Object.keys(OmniScript_1.default);
    }
    getElementFields() {
        return Object.keys(Element_1.default);
    }
    getOmniScriptDefinitionFields() {
        return Object.keys(OmniScriptDefinition_1.default);
    }
    sleep() {
        return new Promise((resolve) => {
            setTimeout(resolve, 5000);
        });
    }
}
exports.OmniScriptMigrationTool = OmniScriptMigrationTool;
// Source Custom Object Names
OmniScriptMigrationTool.OMNISCRIPT_NAME = 'OmniScript__c';
OmniScriptMigrationTool.ELEMENT_NAME = 'Element__c';
OmniScriptMigrationTool.OMNISCRIPTDEFINITION_NAME = 'OmniScriptDefinition__c';
// Target Standard Objects Name
OmniScriptMigrationTool.OMNIPROCESS_NAME = 'OmniProcess';
OmniScriptMigrationTool.OMNIPROCESSELEMENT_NAME = 'OmniProcessElement';
OmniScriptMigrationTool.OMNIPROCESSCOMPILATION_NAME = 'OmniProcessCompilation';
var OmniScriptExportType;
(function (OmniScriptExportType) {
    OmniScriptExportType[OmniScriptExportType["All"] = 0] = "All";
    OmniScriptExportType[OmniScriptExportType["OS"] = 1] = "OS";
    OmniScriptExportType[OmniScriptExportType["IP"] = 2] = "IP";
})(OmniScriptExportType = exports.OmniScriptExportType || (exports.OmniScriptExportType = {}));
//# sourceMappingURL=omniscript.js.map