"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataRaptorMigrationTool = void 0;
const DRBundle_1 = __importDefault(require("../mappings/DRBundle"));
const DRMapItem_1 = __importDefault(require("../mappings/DRMapItem"));
const utils_1 = require("../utils");
const net_1 = require("../utils/net");
const base_1 = require("./base");
class DataRaptorMigrationTool extends base_1.BaseMigrationTool {
    getName() {
        return "DataRaptor";
    }
    getRecordName(record) {
        return record['Name'];
    }
    getMappings() {
        return [{
                source: DataRaptorMigrationTool.DRBUNDLE_NAME,
                target: DataRaptorMigrationTool.OMNIDATATRANSFORM_NAME
            }, {
                source: DataRaptorMigrationTool.DRMAPITEM_NAME,
                target: DataRaptorMigrationTool.OMNIDATATRANSFORMITEM_NAME
            }];
    }
    async truncate() {
        await super.truncate(DataRaptorMigrationTool.OMNIDATATRANSFORM_NAME);
    }
    async migrate() {
        return [await this.MigrateDataRaptorData()];
    }
    async MigrateDataRaptorData() {
        let originalDrRecords = new Map();
        let drUploadInfo = new Map();
        const duplicatedNames = new Set();
        // Query all dataraptors and the respective items
        utils_1.DebugTimer.getInstance().lap('Query data raptors');
        const dataRaptors = await this.getAllDataRaptors();
        const dataRaptorItemsData = await this.getAllItems();
        // Start transforming each dataRaptor
        utils_1.DebugTimer.getInstance().lap('Transform Data Raptor');
        let done = 0;
        const total = dataRaptors.length;
        for (let dr of dataRaptors) {
            this.reportProgress(total, done);
            // Skip if Type is "Migration"
            if (dr[this.namespacePrefix + 'Type__c'] === 'Migration')
                continue;
            const recordId = dr['Id'];
            const name = dr['Name'];
            const typeKey = dr[this.namespacePrefix + 'Type__c'];
            const outputTypeKey = dr[this.namespacePrefix + 'OutputType__c'];
            const targetOutputDocumentIdentifier = dr[this.namespacePrefix + 'TargetOutDocuSignTemplateId__c'];
            const targetOutputFileName = dr[this.namespacePrefix + 'TargetOutPdfDocName__c'];
            if (typeKey === null) {
                dr[this.namespacePrefix + 'Type__c'] = 'Extract';
            }
            // Fix up Input/Output types for older DR's
            switch (typeKey) {
                case 'Transform':
                    dr[this.namespacePrefix + 'Type__c'] = 'Transform';
                    dr[this.namespacePrefix + 'InputType__c'] = 'JSON';
                    if (targetOutputDocumentIdentifier !== null) {
                        dr[this.namespacePrefix + 'OutputType__c'] = 'DocuSign';
                    }
                    else if (targetOutputFileName !== null &&
                        (outputTypeKey !== 'PDF' || outputTypeKey !== 'Document Template')) {
                        dr[this.namespacePrefix + 'OutputType__c'] = 'PDF';
                    }
                    else {
                        dr[this.namespacePrefix + 'OutputType__c'] = 'JSON';
                    }
                    break;
                case 'Extract (JSON)':
                    dr[this.namespacePrefix + 'Type__c'] = 'Extract';
                    dr[this.namespacePrefix + 'InputType__c'] = 'JSON';
                    dr[this.namespacePrefix + 'OutputType__c'] = 'JSON';
                    break;
                case 'Load (JSON)':
                    dr[this.namespacePrefix + 'Type__c'] = 'Load';
                    dr[this.namespacePrefix + 'InputType__c'] = 'JSON';
                    dr[this.namespacePrefix + 'OutputType__c'] = 'SObject';
                    break;
                case 'Load (Object)':
                    dr[this.namespacePrefix + 'Type__c'] = 'Load';
                    dr[this.namespacePrefix + 'InputType__c'] = 'SObject';
                    dr[this.namespacePrefix + 'OutputType__c'] = 'SObject';
                    break;
                default: // no-op;
            }
            // Transform the data raptor
            const transformedDataRaptor = this.mapDataRaptorRecord(dr);
            // Verify duplicated names before trying to submitt
            if (duplicatedNames.has(transformedDataRaptor['Name'])) {
                this.setRecordErrors(dr, this.messages.getMessage('duplicatedDrName'));
                originalDrRecords.set(recordId, dr);
                continue;
            }
            duplicatedNames.add(transformedDataRaptor['Name']);
            // Create a map of the original records
            originalDrRecords.set(recordId, dr);
            // Save the data raptors
            // const drUploadResponse = await this.uploadTransformedData(DataRaptorMigrationTool.OMNIDATATRANSFORM_NAME, { mappedRecords, originalRecords });
            const drUploadResponse = await net_1.NetUtils.createOne(this.connection, DataRaptorMigrationTool.OMNIDATATRANSFORM_NAME, recordId, transformedDataRaptor);
            if (drUploadResponse && drUploadResponse.success === true) {
                const items = await this.getItemsForDataRaptor(dataRaptorItemsData, name, drUploadResponse.id);
                // Check for name changes
                if (transformedDataRaptor[DRBundle_1.default.Name] !== dr['Name']) {
                    drUploadResponse.newName = transformedDataRaptor[DRBundle_1.default.Name];
                }
                // Move the items
                await this.uploadTransformedData(DataRaptorMigrationTool.OMNIDATATRANSFORMITEM_NAME, items);
                drUploadInfo.set(recordId, drUploadResponse);
            }
            done++;
        }
        ;
        return {
            name: 'Data Raptor',
            results: drUploadInfo,
            records: originalDrRecords
        };
    }
    // Get All DRBundle__c records 
    async getAllDataRaptors() {
        utils_1.DebugTimer.getInstance().lap('Query DRBundle');
        return await utils_1.QueryTools.queryAll(this.connection, this.namespace, DataRaptorMigrationTool.DRBUNDLE_NAME, this.getDRBundleFields());
    }
    // Get All Items
    async getAllItems() {
        //Query all Elements
        return await utils_1.QueryTools.queryAll(this.connection, this.namespace, DataRaptorMigrationTool.DRMAPITEM_NAME, this.getDRMapItemFields());
    }
    // Get All Items for one DataRaptor
    async getItemsForDataRaptor(dataRaptorItems, drName, drId) {
        //Query all Elements
        const mappedRecords = [], originalRecords = new Map();
        dataRaptorItems.forEach(drItem => {
            const recordId = drItem['Id'];
            // const itemParentId = drItem[nsPrefix + 'OmniDataTransformationId__c']
            if (drItem['Name'] === drName) {
                mappedRecords.push(this.mapDataRaptorItemData(drItem, drId));
            }
            // Create a map of the original records
            originalRecords.set(recordId, drItem);
        });
        return { originalRecords, mappedRecords };
    }
    /**
     * Maps an indivitdual DRBundle__c record to an OmniDataTransform record.
     * @param dataRaptorRecord
     * @returns
     */
    mapDataRaptorRecord(dataRaptorRecord) {
        // Transformed object
        const mappedObject = {};
        // Get the fields of the record
        const recordFields = Object.keys(dataRaptorRecord);
        // Map individual fields
        recordFields.forEach(recordField => {
            const cleanFieldName = this.getCleanFieldName(recordField);
            if (DRBundle_1.default.hasOwnProperty(cleanFieldName)) {
                mappedObject[DRBundle_1.default[cleanFieldName]] = dataRaptorRecord[recordField];
            }
        });
        mappedObject['Name'] = this.cleanName(mappedObject['Name']);
        mappedObject['IsActive'] = true;
        // BATCH framework requires that each record has an "attributes" property
        mappedObject['attributes'] = {
            type: DataRaptorMigrationTool.OMNIDATATRANSFORM_NAME,
            referenceId: dataRaptorRecord['Id']
        };
        return mappedObject;
    }
    /**
     * Maps an individual DRMapItem__c into an OmniDataTransformId record
     * @param dataRaptorItemRecord
     * @returns
     */
    mapDataRaptorItemData(dataRaptorItemRecord, omniDataTransformationId) {
        // Transformed object
        const mappedObject = {};
        // Get the fields of the record
        const recordFields = Object.keys(dataRaptorItemRecord);
        // Map individual fields
        recordFields.forEach(recordField => {
            const cleanFieldName = this.getCleanFieldName(recordField);
            if (DRMapItem_1.default.hasOwnProperty(cleanFieldName)) {
                mappedObject[DRMapItem_1.default[cleanFieldName]] = dataRaptorItemRecord[recordField];
            }
        });
        // Set the parent/child relationship
        mappedObject['OmniDataTransformationId'] = omniDataTransformationId;
        mappedObject['Name'] = this.cleanName(mappedObject['Name']);
        // BATCH framework requires that each record has an "attributes" property
        mappedObject['attributes'] = {
            type: DataRaptorMigrationTool.OMNIDATATRANSFORMITEM_NAME,
            referenceId: dataRaptorItemRecord['Id']
        };
        return mappedObject;
    }
    getDRBundleFields() {
        return Object.keys(DRBundle_1.default);
    }
    getDRMapItemFields() {
        return Object.keys(DRMapItem_1.default);
    }
}
exports.DataRaptorMigrationTool = DataRaptorMigrationTool;
DataRaptorMigrationTool.DRBUNDLE_NAME = 'DRBundle__c';
DataRaptorMigrationTool.DRMAPITEM_NAME = 'DRMapItem__c';
DataRaptorMigrationTool.OMNIDATATRANSFORM_NAME = 'OmniDataTransform';
DataRaptorMigrationTool.OMNIDATATRANSFORMITEM_NAME = 'OmniDataTransformItem';
//# sourceMappingURL=dataraptor.js.map