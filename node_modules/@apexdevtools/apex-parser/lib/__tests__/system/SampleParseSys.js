"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2022 FinancialForce.com, inc. All rights reserved.
 */
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const __1 = require("../..");
describe("Parse samples", () => {
    // .each runs first before any hooks like beforeAll
    function getSamples() {
        if (!process.env.SAMPLES) {
            throw new Error("Missing environment variable 'SAMPLES' with path to samples.");
        }
        const sampleDir = (0, path_1.resolve)(process.env.SAMPLES);
        return (0, fs_1.readdirSync)(sampleDir)
            .filter(f => !(/(^|\/)\.[^\/\.]/g).test(f)) // not hidden
            .map(f => (0, path_1.resolve)(sampleDir, f)) // full path
            .filter(f => (0, fs_1.lstatSync)(f).isDirectory())
            .map(d => [(0, path_1.basename)(d), d]);
    }
    // disable jest wrapped logging
    const jestConsole = console;
    beforeEach(() => {
        global.console = require("console");
    });
    afterEach(() => {
        global.console = jestConsole;
    });
    test.each(getSamples())("Sample: %s", (_name, path) => __awaiter(void 0, void 0, void 0, function* () {
        const result = yield (0, __1.checkProject)(path);
        expect(result).toMatchSnapshot();
        // run the jvm version of check over same dirs
        result.forEach(r => {
            const jvmCheck = (0, child_process_1.spawnSync)("java", [
                "-cp",
                "jvm/target/dependency/*:jvm/target/apex-parser.jar",
                "io.github.apexdevtools.apexparser.Check",
                (0, path_1.resolve)(path, r.path)
            ], {
                // can only be run from npm dir
                cwd: (0, path_1.resolve)(process.cwd(), ".."),
                timeout: 10000
            });
            const errors = [];
            const logs = [];
            // either >1 or null, truthy check not enough
            if (jvmCheck.status || jvmCheck.status == null) {
                logs.push(...jvmCheck.stderr.toString("utf8").split("\n"));
            }
            else {
                jvmCheck.stdout
                    .toString("utf8")
                    .split("\n")
                    .forEach(l => (l.startsWith("{") ? errors : logs).push(l));
            }
            console.log(logs.filter(l => l).map(s => `(JVM) ${s}`).join("\n"));
            // catch unexpected failures or timeouts
            expect(jvmCheck.status).toEqual(r.status);
            // match syntax errors to snapshot value
            expect(errors.map(j => JSON.parse(j))).toMatchObject(r.errors);
        });
    }), 15000);
});
//# sourceMappingURL=SampleParseSys.js.map